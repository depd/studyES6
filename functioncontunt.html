<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
//			展开运算符(...)
//			展开运算符的作用是解构数组，然后将每个数组元素作为函数参数

//			ES5写法

			let arr = [10, 20, 30, 40, 50];
			let a = Math.max.apply(null,arr);
			console.log(a); // 50
			
//			ES6写法
			let arrs = [10, 20, 30, 40, 50];
			let b = Math.max(...arrs);
			console.log(b); // 50
			
//			箭头函数 ( => )
			
			const arr1 = [5, 10];
			const s = arr1.reduce((sum,item) => sum + item);
			console.log(s); // 15
			
//			reduce 方法 
//			对数组中的所有元素调用指定的回调函数。
//			该回调函数的返回值为累积结果，
//			并且此返回值在下一次调用该回调函数时作为参数提供。
//			arr.reduce(callbackfn[, initialValue]);



//			箭头函数和普通函数的区别是：
//
//			1、箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。
//			
//			2、箭头函数没有super
//			
//			3、箭头函数没有arguments
//			
//			4、箭头函数没有new.target绑定。
//			
//			5、不能使用new
//			
//			6、没有原型
//			
//			7、不支持重复的命名参数。

//			1、箭头函数的左边表示输入的参数，右边表示输出的结果。

			const q = a => a;
			console.log(q(2)); // 2
			
//			2、箭头函数还可以输出对象

			const action = (type, a) => ({
				type:"type",
				a:1
			});
			console.log(action()); // {type:"type",a:1}
			
//			3、支持立即执行函数表达式写法

			const test = ((id) =>{
				return {
					getId(){
						console.log(id);
					}
				}
			})("Aa");
			 test.getId(); // Aa
			
			
//			尾调用优化
//			
//			ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求：
//
//			1、函数不是闭包
//			
//			2、尾调用是函数最后一条语句
//			
//			3、尾调用结果作为函数返回
//			
//			一个满足以上要求的函数如下所示：
//
//		    "use strict";   
//		    function a() {
//		      return b();
//		    }
//		    
//		    下面的都是不满足的写法：
//
//		    //没有return不优化
//		    "use strict";
//		    function a() {
//		      b();
//		    }
//		    
//		    //不是直接返回函数不优化
//		    "use strict";
//		    function a() {
//		      return 1 + b();
//		    }
//		    
//		    //尾调用是函数不是最后一条语句不优化
//		    "use strict";
//		    function a() {
//		      const s = b();
//		      return s
//		    }
//		    
//		    //闭包不优化
//		    "use strict";
//		    function a() {
//		      const num = 1
//		      function b() {
//		        return num
//		      }
//		      return b


		    
		    //			但是有了尾调用优化之后，递归函数的性能有了提升。

		    //新型尾优化写法
		    "use strict";  
		    function w(n, p = 1) {
		      if(n <= 1) {
		        return 1 * p
		      }
		      let s = n * p
		      return w(n - 1, s)
		    }
		    //求 1 x 2 x 3的阶乘
		    let sum = w(3)
		    console.log(sum) // 6
		</script>
	</body>
</html>
